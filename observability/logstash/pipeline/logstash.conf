input {
  beats {
    port => 5044
  }
}

filter {
  # Drop pure infrastructure noise (DBs, Redis, Zipkin, Dapr placement/scheduler)
  # Works when Docker metadata is available; the service-based drop below is the fallback.
  if [container][name] =~ /-(db|redis|zipkin|placement|scheduler)-/ {
    drop { }
  }

  # Parse MongoDB EJSON format and drop it — MongoDB logs look like JSON but use {t, s, c} fields
  if [message] =~ /"t"\s*:\s*\{\s*"\$date"/ {
    drop { }
  }

  # Try to parse JSON log lines emitted by our services
  if [message] =~ /^\s*\{/ {
    json {
      source => "message"
      target => "parsed"
      skip_on_invalid_json => true
    }

    if "_jsonparsefailure" not in [tags] {
      # Use the log's own timestamp if present (overwrite Filebeat's)
      if [parsed][@timestamp] {
        date {
          match => ["[parsed][@timestamp]", "ISO8601"]
          target => "@timestamp"
          remove_field => ["[parsed][@timestamp]"]
        }
      }
      mutate {
        rename => {
          "[parsed][level]"         => "level"
          "[parsed][service]"       => "service"
          "[parsed][correlationId]" => "correlationId"
          "[parsed][action]"        => "action"
          "[parsed][message]"       => "log_message"
          "[parsed][error]"         => "error"
        }
        remove_field => ["parsed"]
      }
    }
  }

  # Tag Dapr sidecar containers
  if [container][name] =~ /.*-dapr$/ {
    mutate {
      add_tag   => ["dapr-sidecar"]
      add_field => { "service" => "dapr-sidecar" }
    }
  }

  # Normalize Serilog Compact level codes: inf→info, wrn→warn, err→error, etc.
  if [level] {
    mutate {
      gsub => [
        "level", "(?i)^inf$", "info",
        "level", "(?i)^wrn$", "warn",
        "level", "(?i)^err$", "error",
        "level", "(?i)^ftl$", "fatal",
        "level", "(?i)^dbg$", "debug",
        "level", "(?i)^vrb$", "trace"
      ]
      lowercase => ["level"]
    }
  }

  # Set a default level for lines that have a service but no level (non-JSON startup lines)
  if [service] and ![level] {
    mutate { add_field => { "level" => "info" } }
  }

  # Drop anything that still has no service — it's infrastructure noise we don't need
  if ![service] {
    drop { }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "car-erp-logs-%{+YYYY.MM.dd}"
  }
}
